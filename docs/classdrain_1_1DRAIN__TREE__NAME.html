<!-- HTML header for doxygen 1.8.17-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>rack: DRAIN_TREE_NAME&lt; T, EXCLUSIVE, P &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="rack.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="rack-logo-110x55.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname"><!-- rack /-->
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacedrain.html">drain</a></li><li class="navelem"><a class="el" href="classdrain_1_1DRAIN__TREE__NAME.html">DRAIN_TREE_NAME</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pro-static-attribs">Static Protected Attributes</a> &#124;
<a href="classdrain_1_1DRAIN__TREE__NAME-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">DRAIN_TREE_NAME&lt; T, EXCLUSIVE, P &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>A templated class for directed rooted trees.  
 <a href="classdrain_1_1DRAIN__TREE__NAME.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="Tree_8h_source.html">Tree.h</a>&gt;</code></p>
<div class="dynheader">
Collaboration diagram for DRAIN_TREE_NAME&lt; T, EXCLUSIVE, P &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classdrain_1_1DRAIN__TREE__NAME__coll__graph.png" border="0" usemap="#aDRAIN__TREE__NAME_3_01T_00_01EXCLUSIVE_00_01P_01_4_coll__map" alt="Collaboration graph"/></div>
<map name="aDRAIN__TREE__NAME_3_01T_00_01EXCLUSIVE_00_01P_01_4_coll__map" id="aDRAIN__TREE__NAME_3_01T_00_01EXCLUSIVE_00_01P_01_4_coll__map">
<area shape="rect" title="A templated class for directed rooted trees." alt="" coords="5,108,183,148"/>
<area shape="rect" href="classdrain_1_1DRAIN__TREE__NAME.html" title="A templated class for directed rooted trees." alt="" coords="5,5,183,45"/>
<area shape="poly" title=" " alt="" coords="97,59,97,108,91,108,91,59"/>
<area shape="poly" title=" " alt="" coords="198,16,209,25,201,33,183,37,182,31,199,29,204,26,195,21"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ac0edcfeb67f4136f621a0871563ef8c8" id="r_ac0edcfeb67f4136f621a0871563ef8c8"><td class="memItemLeft" align="right" valign="top"><a id="ac0edcfeb67f4136f621a0871563ef8c8" name="ac0edcfeb67f4136f621a0871563ef8c8"></a>
typedef <a class="el" href="classdrain_1_1DRAIN__TREE__NAME.html">drain::DRAIN_TREE_NAME</a>&lt; T, EXCLUSIVE, P &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>tree_t</b></td></tr>
<tr class="separator:ac0edcfeb67f4136f621a0871563ef8c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acca0712bb2f9b54e530f4bb41712793f" id="r_acca0712bb2f9b54e530f4bb41712793f"><td class="memItemLeft" align="right" valign="top"><a id="acca0712bb2f9b54e530f4bb41712793f" name="acca0712bb2f9b54e530f4bb41712793f"></a>
typedef T&#160;</td><td class="memItemRight" valign="bottom"><b>node_data_t</b></td></tr>
<tr class="separator:acca0712bb2f9b54e530f4bb41712793f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60f957865ef4c7d0aed8e723fedd24a9" id="r_a60f957865ef4c7d0aed8e723fedd24a9"><td class="memItemLeft" align="right" valign="top"><a id="a60f957865ef4c7d0aed8e723fedd24a9" name="a60f957865ef4c7d0aed8e723fedd24a9"></a>
typedef P&#160;</td><td class="memItemRight" valign="bottom"><b>path_t</b></td></tr>
<tr class="separator:a60f957865ef4c7d0aed8e723fedd24a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18a8eae8c453d6a3460adb188ab5fc8a" id="r_a18a8eae8c453d6a3460adb188ab5fc8a"><td class="memItemLeft" align="right" valign="top"><a id="a18a8eae8c453d6a3460adb188ab5fc8a" name="a18a8eae8c453d6a3460adb188ab5fc8a"></a>
typedef path_t::elem_t&#160;</td><td class="memItemRight" valign="bottom"><b>key_t</b></td></tr>
<tr class="separator:a18a8eae8c453d6a3460adb188ab5fc8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae348d5716574a2c3c623b5ae142872e3" id="r_ae348d5716574a2c3c623b5ae142872e3"><td class="memItemLeft" align="right" valign="top"><a id="ae348d5716574a2c3c623b5ae142872e3" name="ae348d5716574a2c3c623b5ae142872e3"></a>
typedef path_t::elem_t&#160;</td><td class="memItemRight" valign="bottom"><b>path_elem_t</b></td></tr>
<tr class="separator:ae348d5716574a2c3c623b5ae142872e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab87795fccb8fa016d4dd51c91e37aee3" id="r_ab87795fccb8fa016d4dd51c91e37aee3"><td class="memItemLeft" align="right" valign="top"><a id="ab87795fccb8fa016d4dd51c91e37aee3" name="ab87795fccb8fa016d4dd51c91e37aee3"></a>
typedef std::pair&lt; key_t, <a class="el" href="classdrain_1_1DRAIN__TREE__NAME.html">tree_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>pair_t</b></td></tr>
<tr class="separator:ab87795fccb8fa016d4dd51c91e37aee3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c2aa299a3708fbd0653c10b389e1a7f" id="r_a2c2aa299a3708fbd0653c10b389e1a7f"><td class="memItemLeft" align="right" valign="top"><a id="a2c2aa299a3708fbd0653c10b389e1a7f" name="a2c2aa299a3708fbd0653c10b389e1a7f"></a>
typedef container_t::iterator&#160;</td><td class="memItemRight" valign="bottom"><b>iterator</b></td></tr>
<tr class="separator:a2c2aa299a3708fbd0653c10b389e1a7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad84fdc3698b7d38ce36401acc76037d9" id="r_ad84fdc3698b7d38ce36401acc76037d9"><td class="memItemLeft" align="right" valign="top"><a id="ad84fdc3698b7d38ce36401acc76037d9" name="ad84fdc3698b7d38ce36401acc76037d9"></a>
typedef container_t::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>const_iterator</b></td></tr>
<tr class="separator:ad84fdc3698b7d38ce36401acc76037d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac952a53f380ebb1671f3421a270e156b" id="r_ac952a53f380ebb1671f3421a270e156b"><td class="memItemLeft" align="right" valign="top"><a id="ac952a53f380ebb1671f3421a270e156b" name="ac952a53f380ebb1671f3421a270e156b"></a>
typedef std::pair&lt; key_t, node_data_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>node_pair_t</b></td></tr>
<tr class="memdesc:ac952a53f380ebb1671f3421a270e156b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Experimental. Given pair&lt;elem, data&gt; assigns child[elem] = data;. <br /></td></tr>
<tr class="separator:ac952a53f380ebb1671f3421a270e156b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:adff1b5a7829e677dcfe92e6bebbc994f" id="r_adff1b5a7829e677dcfe92e6bebbc994f"><td class="memItemLeft" align="right" valign="top"><a id="adff1b5a7829e677dcfe92e6bebbc994f" name="adff1b5a7829e677dcfe92e6bebbc994f"></a>
typedef&#160;</td><td class="memItemRight" valign="bottom"><b>DRAIN_TREE_CONTAINER</b> (key_t, <a class="el" href="classdrain_1_1DRAIN__TREE__NAME.html">tree_t</a>) container_t</td></tr>
<tr class="separator:adff1b5a7829e677dcfe92e6bebbc994f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad38ef804f0ccedc2ff064214fef789c" id="r_aad38ef804f0ccedc2ff064214fef789c"><td class="memItemLeft" align="right" valign="top"><a id="aad38ef804f0ccedc2ff064214fef789c" name="aad38ef804f0ccedc2ff064214fef789c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>DRAIN_TREE_NAME</b> ()</td></tr>
<tr class="memdesc:aad38ef804f0ccedc2ff064214fef789c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor. <br /></td></tr>
<tr class="separator:aad38ef804f0ccedc2ff064214fef789c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3a1bd0813a2b60907a814cb300d3da3" id="r_ad3a1bd0813a2b60907a814cb300d3da3"><td class="memItemLeft" align="right" valign="top"><a id="ad3a1bd0813a2b60907a814cb300d3da3" name="ad3a1bd0813a2b60907a814cb300d3da3"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>DRAIN_TREE_NAME</b> (const node_data_t &amp;<a class="el" href="classdrain_1_1DRAIN__TREE__NAME.html#a36fa01075ecacd03b83c14c5385d7a67">data</a>)</td></tr>
<tr class="memdesc:ad3a1bd0813a2b60907a814cb300d3da3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor; copy only node data at the root. <br /></td></tr>
<tr class="separator:ad3a1bd0813a2b60907a814cb300d3da3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77d888f8b37470421e92957c30e7d3ae" id="r_a77d888f8b37470421e92957c30e7d3ae"><td class="memItemLeft" align="right" valign="top"><a id="a77d888f8b37470421e92957c30e7d3ae" name="a77d888f8b37470421e92957c30e7d3ae"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>DRAIN_TREE_NAME</b> (const <a class="el" href="classdrain_1_1DRAIN__TREE__NAME.html">DRAIN_TREE_NAME</a> &amp;t)</td></tr>
<tr class="memdesc:a77d888f8b37470421e92957c30e7d3ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor; copy only node data at the root. <br /></td></tr>
<tr class="separator:a77d888f8b37470421e92957c30e7d3ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88f8e5231077914dccea325dc40eb195" id="r_a88f8e5231077914dccea325dc40eb195"><td class="memItemLeft" align="right" valign="top"><a id="a88f8e5231077914dccea325dc40eb195" name="a88f8e5231077914dccea325dc40eb195"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>hasMultipleData</b> () const</td></tr>
<tr class="separator:a88f8e5231077914dccea325dc40eb195"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af288413a6e6672c1bc56baadc89a5b20" id="r_af288413a6e6672c1bc56baadc89a5b20"><td class="memItemLeft" align="right" valign="top"><a id="af288413a6e6672c1bc56baadc89a5b20" name="af288413a6e6672c1bc56baadc89a5b20"></a>
virtual const node_data_t &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getData</b> () const</td></tr>
<tr class="separator:af288413a6e6672c1bc56baadc89a5b20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5379f7f106a81450ac0ba10801dd7f3" id="r_ab5379f7f106a81450ac0ba10801dd7f3"><td class="memItemLeft" align="right" valign="top"><a id="ab5379f7f106a81450ac0ba10801dd7f3" name="ab5379f7f106a81450ac0ba10801dd7f3"></a>
virtual node_data_t &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getData</b> ()</td></tr>
<tr class="separator:ab5379f7f106a81450ac0ba10801dd7f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addf005d41770374f030666bd4c24cda8" id="r_addf005d41770374f030666bd4c24cda8"><td class="memItemLeft" align="right" valign="top"><a id="addf005d41770374f030666bd4c24cda8" name="addf005d41770374f030666bd4c24cda8"></a>
virtual const node_data_t &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getData</b> (const key_t &amp;key) const</td></tr>
<tr class="separator:addf005d41770374f030666bd4c24cda8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c30c608cd42abd182ed0b929f8ef976" id="r_a5c30c608cd42abd182ed0b929f8ef976"><td class="memItemLeft" align="right" valign="top"><a id="a5c30c608cd42abd182ed0b929f8ef976" name="a5c30c608cd42abd182ed0b929f8ef976"></a>
virtual node_data_t &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getData</b> (const key_t &amp;key)</td></tr>
<tr class="separator:a5c30c608cd42abd182ed0b929f8ef976"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd233a567e2ef795e98c75cdb37336db" id="r_acd233a567e2ef795e98c75cdb37336db"><td class="memItemLeft" align="right" valign="top"><a id="acd233a567e2ef795e98c75cdb37336db" name="acd233a567e2ef795e98c75cdb37336db"></a>
container_t::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>begin</b> () const</td></tr>
<tr class="memdesc:acd233a567e2ef795e98c75cdb37336db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Child iterator pointing to the first child. <br /></td></tr>
<tr class="separator:acd233a567e2ef795e98c75cdb37336db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fc71669d8d9e77d86e749b72e7ec162" id="r_a1fc71669d8d9e77d86e749b72e7ec162"><td class="memItemLeft" align="right" valign="top"><a id="a1fc71669d8d9e77d86e749b72e7ec162" name="a1fc71669d8d9e77d86e749b72e7ec162"></a>
container_t::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>end</b> () const</td></tr>
<tr class="memdesc:a1fc71669d8d9e77d86e749b72e7ec162"><td class="mdescLeft">&#160;</td><td class="mdescRight">Child iterator pointing beyond the last child. <br /></td></tr>
<tr class="separator:a1fc71669d8d9e77d86e749b72e7ec162"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40f2c4878612b3e120667b10a121e864" id="r_a40f2c4878612b3e120667b10a121e864"><td class="memItemLeft" align="right" valign="top"><a id="a40f2c4878612b3e120667b10a121e864" name="a40f2c4878612b3e120667b10a121e864"></a>
container_t::iterator&#160;</td><td class="memItemRight" valign="bottom"><b>begin</b> ()</td></tr>
<tr class="memdesc:a40f2c4878612b3e120667b10a121e864"><td class="mdescLeft">&#160;</td><td class="mdescRight">Child iterator pointing to the first child. <br /></td></tr>
<tr class="separator:a40f2c4878612b3e120667b10a121e864"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdbe1b3241957d4062ec8683399520a4" id="r_acdbe1b3241957d4062ec8683399520a4"><td class="memItemLeft" align="right" valign="top"><a id="acdbe1b3241957d4062ec8683399520a4" name="acdbe1b3241957d4062ec8683399520a4"></a>
container_t::iterator&#160;</td><td class="memItemRight" valign="bottom"><b>end</b> ()</td></tr>
<tr class="memdesc:acdbe1b3241957d4062ec8683399520a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Child iterator end. <br /></td></tr>
<tr class="separator:acdbe1b3241957d4062ec8683399520a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2aec2b27c82ec45ce0f006cb62f85bf2" id="r_a2aec2b27c82ec45ce0f006cb62f85bf2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrain_1_1DRAIN__TREE__NAME.html">tree_t</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrain_1_1DRAIN__TREE__NAME.html#a2aec2b27c82ec45ce0f006cb62f85bf2">operator=</a> (const <a class="el" href="classdrain_1_1DRAIN__TREE__NAME.html">tree_t</a> &amp;t)</td></tr>
<tr class="memdesc:a2aec2b27c82ec45ce0f006cb62f85bf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the data of another node. Does not copy the children.  <br /></td></tr>
<tr class="separator:a2aec2b27c82ec45ce0f006cb62f85bf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b112726e65b27df1258160ad59c7fa9" id="r_a9b112726e65b27df1258160ad59c7fa9"><td class="memTemplParams" colspan="2">template&lt;class T2 &gt; </td></tr>
<tr class="memitem:a9b112726e65b27df1258160ad59c7fa9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classdrain_1_1DRAIN__TREE__NAME.html">tree_t</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrain_1_1DRAIN__TREE__NAME.html#a9b112726e65b27df1258160ad59c7fa9">operator=</a> (const T2 &amp;v)</td></tr>
<tr class="memdesc:a9b112726e65b27df1258160ad59c7fa9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns value to contents.  <br /></td></tr>
<tr class="separator:a9b112726e65b27df1258160ad59c7fa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a657c4d9a371e5f1933ad97427266f948" id="r_a657c4d9a371e5f1933ad97427266f948"><td class="memItemLeft" align="right" valign="top"><a id="a657c4d9a371e5f1933ad97427266f948" name="a657c4d9a371e5f1933ad97427266f948"></a>
<a class="el" href="classdrain_1_1DRAIN__TREE__NAME.html">tree_t</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const char *str)</td></tr>
<tr class="separator:a657c4d9a371e5f1933ad97427266f948"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63826658ff44573948e9ec387448681f" id="r_a63826658ff44573948e9ec387448681f"><td class="memTemplParams" colspan="2">template&lt;typename K , typename V &gt; </td></tr>
<tr class="memitem:a63826658ff44573948e9ec387448681f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classdrain_1_1DRAIN__TREE__NAME.html">tree_t</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrain_1_1DRAIN__TREE__NAME.html#a63826658ff44573948e9ec387448681f">operator=</a> (std::initializer_list&lt; std::pair&lt; K, V &gt; &gt; l)</td></tr>
<tr class="memdesc:a63826658ff44573948e9ec387448681f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign tree structure (of depth one).  <br /></td></tr>
<tr class="separator:a63826658ff44573948e9ec387448681f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af682d01b973b014c8b745eb0b183a77f" id="r_af682d01b973b014c8b745eb0b183a77f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrain_1_1DRAIN__TREE__NAME.html">tree_t</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrain_1_1DRAIN__TREE__NAME.html#af682d01b973b014c8b745eb0b183a77f">operator=</a> (std::initializer_list&lt; std::pair&lt; const char *, const <a class="el" href="namespacedrain.html#ab7d12e28978bddd9b2fda7142a1c0420">Variable</a> &gt; &gt; l)</td></tr>
<tr class="memdesc:af682d01b973b014c8b745eb0b183a77f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign tree structure (of depth one).  <br /></td></tr>
<tr class="separator:af682d01b973b014c8b745eb0b183a77f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cdae6a828244f1c0d536ed626920f06" id="r_a3cdae6a828244f1c0d536ed626920f06"><td class="memTemplParams" colspan="2">template&lt;typename V &gt; </td></tr>
<tr class="memitem:a3cdae6a828244f1c0d536ed626920f06"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classdrain_1_1DRAIN__TREE__NAME.html">tree_t</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrain_1_1DRAIN__TREE__NAME.html#a3cdae6a828244f1c0d536ed626920f06">operator=</a> (const std::initializer_list&lt; V &gt; &amp;l)</td></tr>
<tr class="memdesc:a3cdae6a828244f1c0d536ed626920f06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign data.  <br /></td></tr>
<tr class="separator:a3cdae6a828244f1c0d536ed626920f06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac8e3285b400ae9f76ec76d1fb5168d5" id="r_aac8e3285b400ae9f76ec76d1fb5168d5"><td class="memItemLeft" align="right" valign="top"><a id="aac8e3285b400ae9f76ec76d1fb5168d5" name="aac8e3285b400ae9f76ec76d1fb5168d5"></a>
<a class="el" href="classdrain_1_1DRAIN__TREE__NAME.html">tree_t</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (const <a class="el" href="classdrain_1_1DRAIN__TREE__NAME.html#ac952a53f380ebb1671f3421a270e156b">node_pair_t</a> &amp;entry)</td></tr>
<tr class="memdesc:aac8e3285b400ae9f76ec76d1fb5168d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Experimental. Given pair(elem, data) assigns child[elem] = data;. <br /></td></tr>
<tr class="separator:aac8e3285b400ae9f76ec76d1fb5168d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30df81da77e31bc9b1b803ed67481349" id="r_a30df81da77e31bc9b1b803ed67481349"><td class="memItemLeft" align="right" valign="top"><a id="a30df81da77e31bc9b1b803ed67481349" name="a30df81da77e31bc9b1b803ed67481349"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>operator const node_data_t &amp;</b> () const</td></tr>
<tr class="separator:a30df81da77e31bc9b1b803ed67481349"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a506d28087dce1cb8836dc9799279e9ac" id="r_a506d28087dce1cb8836dc9799279e9ac"><td class="memItemLeft" align="right" valign="top"><a id="a506d28087dce1cb8836dc9799279e9ac" name="a506d28087dce1cb8836dc9799279e9ac"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>operator node_data_t &amp;</b> ()</td></tr>
<tr class="separator:a506d28087dce1cb8836dc9799279e9ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae431db3fddd72d86bc94f0a5455ee97c" id="r_ae431db3fddd72d86bc94f0a5455ee97c"><td class="memItemLeft" align="right" valign="top"><a id="ae431db3fddd72d86bc94f0a5455ee97c" name="ae431db3fddd72d86bc94f0a5455ee97c"></a>
<a class="el" href="classdrain_1_1DRAIN__TREE__NAME.html">tree_t</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator[]</b> (const key_t &amp;key)</td></tr>
<tr class="memdesc:ae431db3fddd72d86bc94f0a5455ee97c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Child addressing operator. <br /></td></tr>
<tr class="separator:ae431db3fddd72d86bc94f0a5455ee97c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86bcdfc6143e7c644594882fec087a9e" id="r_a86bcdfc6143e7c644594882fec087a9e"><td class="memItemLeft" align="right" valign="top"><a id="a86bcdfc6143e7c644594882fec087a9e" name="a86bcdfc6143e7c644594882fec087a9e"></a>
const <a class="el" href="classdrain_1_1DRAIN__TREE__NAME.html">tree_t</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator[]</b> (const key_t &amp;key) const</td></tr>
<tr class="memdesc:a86bcdfc6143e7c644594882fec087a9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Child addressing operator. <br /></td></tr>
<tr class="separator:a86bcdfc6143e7c644594882fec087a9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cc2f3512809bfa39f7bddec594be2f4" id="r_a0cc2f3512809bfa39f7bddec594be2f4"><td class="memTemplParams" colspan="2">template&lt;class K &gt; </td></tr>
<tr class="memitem:a0cc2f3512809bfa39f7bddec594be2f4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classdrain_1_1DRAIN__TREE__NAME.html">tree_t</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrain_1_1DRAIN__TREE__NAME.html#a0cc2f3512809bfa39f7bddec594be2f4">operator[]</a> (const K &amp;key)</td></tr>
<tr class="memdesc:a0cc2f3512809bfa39f7bddec594be2f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">NEW 2025 templated child addressing operator.  <br /></td></tr>
<tr class="separator:a0cc2f3512809bfa39f7bddec594be2f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a474425352ec70a62de24dbe20ebff364" id="r_a474425352ec70a62de24dbe20ebff364"><td class="memTemplParams" colspan="2"><a id="a474425352ec70a62de24dbe20ebff364" name="a474425352ec70a62de24dbe20ebff364"></a>
template&lt;class K &gt; </td></tr>
<tr class="memitem:a474425352ec70a62de24dbe20ebff364"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classdrain_1_1DRAIN__TREE__NAME.html">tree_t</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator[]</b> (const K &amp;key) const</td></tr>
<tr class="memdesc:a474425352ec70a62de24dbe20ebff364"><td class="mdescLeft">&#160;</td><td class="mdescRight">NEW 2025 templated child addressing operator. <br /></td></tr>
<tr class="separator:a474425352ec70a62de24dbe20ebff364"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae42dc21078ae07664553b21bf2a294fb" id="r_ae42dc21078ae07664553b21bf2a294fb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrain_1_1DRAIN__TREE__NAME.html">tree_t</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrain_1_1DRAIN__TREE__NAME.html#ae42dc21078ae07664553b21bf2a294fb">operator()</a> (const path_t &amp;path)</td></tr>
<tr class="memdesc:ae42dc21078ae07664553b21bf2a294fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a descendant. Creates one if not existing already.  <br /></td></tr>
<tr class="separator:ae42dc21078ae07664553b21bf2a294fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab35f42633928b482d9ef2fea4fc9f2c8" id="r_ab35f42633928b482d9ef2fea4fc9f2c8"><td class="memTemplParams" colspan="2">template&lt;class S &gt; </td></tr>
<tr class="memitem:ab35f42633928b482d9ef2fea4fc9f2c8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classdrain_1_1DRAIN__TREE__NAME.html">tree_t</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrain_1_1DRAIN__TREE__NAME.html#ab35f42633928b482d9ef2fea4fc9f2c8">operator()</a> (const S &amp;arg)</td></tr>
<tr class="memdesc:ab35f42633928b482d9ef2fea4fc9f2c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a descendant. Creates one if not existing already.  <br /></td></tr>
<tr class="separator:ab35f42633928b482d9ef2fea4fc9f2c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a474445bff1b6006c536048878860f80b" id="r_a474445bff1b6006c536048878860f80b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrain_1_1DRAIN__TREE__NAME.html">tree_t</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrain_1_1DRAIN__TREE__NAME.html#a474445bff1b6006c536048878860f80b">operator()</a> (const char *arg)</td></tr>
<tr class="memdesc:a474445bff1b6006c536048878860f80b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Redirects the call to operator()(const std::string &amp; arg) .  <br /></td></tr>
<tr class="separator:a474445bff1b6006c536048878860f80b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52ff5144d38c35429c32a7aab8289845" id="r_a52ff5144d38c35429c32a7aab8289845"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrain_1_1DRAIN__TREE__NAME.html">tree_t</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrain_1_1DRAIN__TREE__NAME.html#a52ff5144d38c35429c32a7aab8289845">operator()</a> (const path_t &amp;path) const</td></tr>
<tr class="memdesc:a52ff5144d38c35429c32a7aab8289845"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a descendant if that exists, else returns an empty node. Otherwise like non-const counterpart.  <br /></td></tr>
<tr class="separator:a52ff5144d38c35429c32a7aab8289845"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b5a1ce59ff355f341b0631d57fbeb03" id="r_a7b5a1ce59ff355f341b0631d57fbeb03"><td class="memTemplParams" colspan="2"><a id="a7b5a1ce59ff355f341b0631d57fbeb03" name="a7b5a1ce59ff355f341b0631d57fbeb03"></a>
template&lt;class S &gt; </td></tr>
<tr class="memitem:a7b5a1ce59ff355f341b0631d57fbeb03"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classdrain_1_1DRAIN__TREE__NAME.html">tree_t</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator()</b> (const S &amp;arg) const</td></tr>
<tr class="memdesc:a7b5a1ce59ff355f341b0631d57fbeb03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a descendant if that exists, else returns an empty node. Otherwise like non-const counterpart. <br /></td></tr>
<tr class="separator:a7b5a1ce59ff355f341b0631d57fbeb03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a144f60e77d06085f52b548b17cebdef0" id="r_a144f60e77d06085f52b548b17cebdef0"><td class="memItemLeft" align="right" valign="top"><a id="a144f60e77d06085f52b548b17cebdef0" name="a144f60e77d06085f52b548b17cebdef0"></a>
const <a class="el" href="classdrain_1_1DRAIN__TREE__NAME.html">tree_t</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator()</b> (const char *arg) const</td></tr>
<tr class="memdesc:a144f60e77d06085f52b548b17cebdef0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Redirects the call to operator()(const std::string &amp; arg) . <br /></td></tr>
<tr class="separator:a144f60e77d06085f52b548b17cebdef0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8bb3912a3ce86b15842e79d0b421204" id="r_ac8bb3912a3ce86b15842e79d0b421204"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrain_1_1DRAIN__TREE__NAME.html#ac8bb3912a3ce86b15842e79d0b421204">clear</a> ()</td></tr>
<tr class="memdesc:ac8bb3912a3ce86b15842e79d0b421204"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear children and node data.  <br /></td></tr>
<tr class="separator:ac8bb3912a3ce86b15842e79d0b421204"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd4e5c937c4b98dd42745acb33815cdf" id="r_abd4e5c937c4b98dd42745acb33815cdf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrain_1_1DRAIN__TREE__NAME.html#abd4e5c937c4b98dd42745acb33815cdf">clearData</a> ()</td></tr>
<tr class="separator:abd4e5c937c4b98dd42745acb33815cdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a091c6265950643e307d70411dab30bc7" id="r_a091c6265950643e307d70411dab30bc7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrain_1_1DRAIN__TREE__NAME.html#a091c6265950643e307d70411dab30bc7">clearChildren</a> ()</td></tr>
<tr class="memdesc:a091c6265950643e307d70411dab30bc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the children of this node. Does not clear data.  <br /></td></tr>
<tr class="separator:a091c6265950643e307d70411dab30bc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3b723ff8f1045f2b4c2a8fae13c3989" id="r_aa3b723ff8f1045f2b4c2a8fae13c3989"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrain_1_1DRAIN__TREE__NAME.html#aa3b723ff8f1045f2b4c2a8fae13c3989">erase</a> (const path_t &amp;path)</td></tr>
<tr class="memdesc:aa3b723ff8f1045f2b4c2a8fae13c3989"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes a descendant node and hence its subtrees.  <br /></td></tr>
<tr class="separator:aa3b723ff8f1045f2b4c2a8fae13c3989"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47f00b880022a29d4000212fdd412ed4" id="r_a47f00b880022a29d4000212fdd412ed4"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classdrain_1_1DRAIN__TREE__NAME.html">tree_t</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrain_1_1DRAIN__TREE__NAME.html#a47f00b880022a29d4000212fdd412ed4">getEmpty</a> () const</td></tr>
<tr class="separator:a47f00b880022a29d4000212fdd412ed4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dc9d7494d137f8725d90c21d037fe4a" id="r_a5dc9d7494d137f8725d90c21d037fe4a"><td class="memItemLeft" align="right" valign="top"><a id="a5dc9d7494d137f8725d90c21d037fe4a" name="a5dc9d7494d137f8725d90c21d037fe4a"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>empty</b> () const</td></tr>
<tr class="memdesc:a5dc9d7494d137f8725d90c21d037fe4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the tree structure is empty. <br /></td></tr>
<tr class="separator:a5dc9d7494d137f8725d90c21d037fe4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abae2ef4777ea28fa9acc234111dc84eb" id="r_abae2ef4777ea28fa9acc234111dc84eb"><td class="memItemLeft" align="right" valign="top"><a id="abae2ef4777ea28fa9acc234111dc84eb" name="abae2ef4777ea28fa9acc234111dc84eb"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>hasChildren</b> () const</td></tr>
<tr class="separator:abae2ef4777ea28fa9acc234111dc84eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a005a8565608b53d552ed49c05a9e3361" id="r_a005a8565608b53d552ed49c05a9e3361"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrain_1_1DRAIN__TREE__NAME.html#a005a8565608b53d552ed49c05a9e3361">hasChildren</a> (const key_t &amp;key) const</td></tr>
<tr class="memdesc:a005a8565608b53d552ed49c05a9e3361"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of children with name key.  <br /></td></tr>
<tr class="separator:a005a8565608b53d552ed49c05a9e3361"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac729ceb49af576a8ddac20f4bb8e3f45" id="r_ac729ceb49af576a8ddac20f4bb8e3f45"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrain_1_1DRAIN__TREE__NAME.html#ac729ceb49af576a8ddac20f4bb8e3f45">hasChild</a> (const key_t &amp;key) const</td></tr>
<tr class="memdesc:ac729ceb49af576a8ddac20f4bb8e3f45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the tree node has a direct descendant with name <code>key</code>.  <br /></td></tr>
<tr class="separator:ac729ceb49af576a8ddac20f4bb8e3f45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabaa298fd574849874ce8ac3e459b94b" id="r_aabaa298fd574849874ce8ac3e459b94b"><td class="memTemplParams" colspan="2"><a id="aabaa298fd574849874ce8ac3e459b94b" name="aabaa298fd574849874ce8ac3e459b94b"></a>
template&lt;typename K &gt; </td></tr>
<tr class="memitem:aabaa298fd574849874ce8ac3e459b94b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>hasChild</b> (const K &amp;key) const</td></tr>
<tr class="separator:aabaa298fd574849874ce8ac3e459b94b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65f43af37f0ed7b8ffe1efcbab9ba334" id="r_a65f43af37f0ed7b8ffe1efcbab9ba334"><td class="memItemLeft" align="right" valign="top"><a id="a65f43af37f0ed7b8ffe1efcbab9ba334" name="a65f43af37f0ed7b8ffe1efcbab9ba334"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>hasPath</b> (const path_t &amp;path) const</td></tr>
<tr class="separator:a65f43af37f0ed7b8ffe1efcbab9ba334"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a096ce1ab7533a296351b535765aadd3a" id="r_a096ce1ab7533a296351b535765aadd3a"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdrain_1_1DRAIN__TREE__NAME.html">tree_t</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrain_1_1DRAIN__TREE__NAME.html#a096ce1ab7533a296351b535765aadd3a">addChild</a> (const key_t &amp;key=key_t())</td></tr>
<tr class="memdesc:a096ce1ab7533a296351b535765aadd3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a child node. If unordered and UNIQUE, reuse existing nodes.  <br /></td></tr>
<tr class="separator:a096ce1ab7533a296351b535765aadd3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfb1a6c1c17c6c344605b489ac155a8e" id="r_adfb1a6c1c17c6c344605b489ac155a8e"><td class="memItemLeft" align="right" valign="top"><a id="adfb1a6c1c17c6c344605b489ac155a8e" name="adfb1a6c1c17c6c344605b489ac155a8e"></a>
virtual <a class="el" href="classdrain_1_1DRAIN__TREE__NAME.html">tree_t</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>retrieveChild</b> (const key_t &amp;key)</td></tr>
<tr class="separator:adfb1a6c1c17c6c344605b489ac155a8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9472279334db77eb165ac8411f22d3d" id="r_af9472279334db77eb165ac8411f22d3d"><td class="memItemLeft" align="right" valign="top"><a id="af9472279334db77eb165ac8411f22d3d" name="af9472279334db77eb165ac8411f22d3d"></a>
virtual const <a class="el" href="classdrain_1_1DRAIN__TREE__NAME.html">tree_t</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>retrieveChild</b> (const key_t &amp;key) const</td></tr>
<tr class="separator:af9472279334db77eb165ac8411f22d3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa450468894c0ff2066310624173c0152" id="r_aa450468894c0ff2066310624173c0152"><td class="memItemLeft" align="right" valign="top">container_t &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrain_1_1DRAIN__TREE__NAME.html#aa450468894c0ff2066310624173c0152">getChildren</a> ()</td></tr>
<tr class="memdesc:aa450468894c0ff2066310624173c0152"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the map containing the children.  <br /></td></tr>
<tr class="separator:aa450468894c0ff2066310624173c0152"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61e194b097b7f4b38baa3f8166074a98" id="r_a61e194b097b7f4b38baa3f8166074a98"><td class="memItemLeft" align="right" valign="top"><a id="a61e194b097b7f4b38baa3f8166074a98" name="a61e194b097b7f4b38baa3f8166074a98"></a>
const container_t &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getChildren</b> () const</td></tr>
<tr class="memdesc:a61e194b097b7f4b38baa3f8166074a98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the map containing the children. <br /></td></tr>
<tr class="separator:a61e194b097b7f4b38baa3f8166074a98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8207a17978c83921d9e91721e3b258a3" id="r_a8207a17978c83921d9e91721e3b258a3"><td class="memItemLeft" align="right" valign="top"><a id="a8207a17978c83921d9e91721e3b258a3" name="a8207a17978c83921d9e91721e3b258a3"></a>
const node_data_t *&#160;</td><td class="memItemRight" valign="bottom"><b>operator-&gt;</b> () const</td></tr>
<tr class="memdesc:a8207a17978c83921d9e91721e3b258a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fast access to data, applied widely in TreeXML (HTML/SVG) <br /></td></tr>
<tr class="separator:a8207a17978c83921d9e91721e3b258a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b58f593a9f0839614f1b14bf5ebcbd9" id="r_a9b58f593a9f0839614f1b14bf5ebcbd9"><td class="memItemLeft" align="right" valign="top"><a id="a9b58f593a9f0839614f1b14bf5ebcbd9" name="a9b58f593a9f0839614f1b14bf5ebcbd9"></a>
node_data_t *&#160;</td><td class="memItemRight" valign="bottom"><b>operator-&gt;</b> ()</td></tr>
<tr class="memdesc:a9b58f593a9f0839614f1b14bf5ebcbd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fast access to data, applied widely in TreeXML (HTML/SVG) <br /></td></tr>
<tr class="separator:a9b58f593a9f0839614f1b14bf5ebcbd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11d598ca144b69a123f2e2d9ee42af3d" id="r_a11d598ca144b69a123f2e2d9ee42af3d"><td class="memItemLeft" align="right" valign="top"><a id="a11d598ca144b69a123f2e2d9ee42af3d" name="a11d598ca144b69a123f2e2d9ee42af3d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>swap</b> (<a class="el" href="classdrain_1_1DRAIN__TREE__NAME.html">tree_t</a> &amp;t)</td></tr>
<tr class="memdesc:a11d598ca144b69a123f2e2d9ee42af3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace children (but no data?) <br /></td></tr>
<tr class="separator:a11d598ca144b69a123f2e2d9ee42af3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a7f62b1a68eb97169aedcda208258ba84" id="r_a7f62b1a68eb97169aedcda208258ba84"><td class="memItemLeft" align="right" valign="top"><a id="a7f62b1a68eb97169aedcda208258ba84" name="a7f62b1a68eb97169aedcda208258ba84"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><b>isExclusive</b> ()</td></tr>
<tr class="separator:a7f62b1a68eb97169aedcda208258ba84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d90046ff6d5add673806dce67701111" id="r_a0d90046ff6d5add673806dce67701111"><td class="memItemLeft" align="right" valign="top"><a id="a0d90046ff6d5add673806dce67701111" name="a0d90046ff6d5add673806dce67701111"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><b>isMulti</b> ()</td></tr>
<tr class="separator:a0d90046ff6d5add673806dce67701111"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef760f75eac06ce2710a8f0aa1e8c9e6" id="r_aef760f75eac06ce2710a8f0aa1e8c9e6"><td class="memItemLeft" align="right" valign="top"><a id="aef760f75eac06ce2710a8f0aa1e8c9e6" name="aef760f75eac06ce2710a8f0aa1e8c9e6"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><b>isOrdered</b> ()</td></tr>
<tr class="separator:aef760f75eac06ce2710a8f0aa1e8c9e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a36fa01075ecacd03b83c14c5385d7a67" id="r_a36fa01075ecacd03b83c14c5385d7a67"><td class="memItemLeft" align="right" valign="top"><a id="a36fa01075ecacd03b83c14c5385d7a67" name="a36fa01075ecacd03b83c14c5385d7a67"></a>
node_data_t&#160;</td><td class="memItemRight" valign="bottom"><b>data</b></td></tr>
<tr class="memdesc:a36fa01075ecacd03b83c14c5385d7a67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contents (data) of the node. <br /></td></tr>
<tr class="separator:a36fa01075ecacd03b83c14c5385d7a67"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a91080c09ebdb9bd501d9c244aec87d7a" id="r_a91080c09ebdb9bd501d9c244aec87d7a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrain_1_1DRAIN__TREE__NAME.html#a91080c09ebdb9bd501d9c244aec87d7a">hasPath</a> (typename path_t::const_iterator it, typename path_t::const_iterator eit) const</td></tr>
<tr class="memdesc:a91080c09ebdb9bd501d9c244aec87d7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">"Default implementation" of key conversion – the identity mapping.  <br /></td></tr>
<tr class="separator:a91080c09ebdb9bd501d9c244aec87d7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af83443d6cd66b44c03289e73aa95e3ee" id="r_af83443d6cd66b44c03289e73aa95e3ee"><td class="memItemLeft" align="right" valign="top"><a id="af83443d6cd66b44c03289e73aa95e3ee" name="af83443d6cd66b44c03289e73aa95e3ee"></a>
<a class="el" href="classdrain_1_1DRAIN__TREE__NAME.html">tree_t</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>get</b> (typename path_t::const_iterator it, typename path_t::const_iterator eit)</td></tr>
<tr class="memdesc:af83443d6cd66b44c03289e73aa95e3ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a descendant. Creates one, if not present. <br /></td></tr>
<tr class="separator:af83443d6cd66b44c03289e73aa95e3ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b34f007b6dcdf7090e2e49d370c86fa" id="r_a1b34f007b6dcdf7090e2e49d370c86fa"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrain_1_1DRAIN__TREE__NAME.html">tree_t</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrain_1_1DRAIN__TREE__NAME.html#a1b34f007b6dcdf7090e2e49d370c86fa">get</a> (typename path_t::const_iterator it, typename path_t::const_iterator eit) const</td></tr>
<tr class="memdesc:a1b34f007b6dcdf7090e2e49d370c86fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given the descendant pointed to by a given path segment.  <br /></td></tr>
<tr class="separator:a1b34f007b6dcdf7090e2e49d370c86fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a3df3d5bee8754d56741a72ffa9494fad" id="r_a3df3d5bee8754d56741a72ffa9494fad"><td class="memItemLeft" align="right" valign="top"><a id="a3df3d5bee8754d56741a72ffa9494fad" name="a3df3d5bee8754d56741a72ffa9494fad"></a>
container_t&#160;</td><td class="memItemRight" valign="bottom"><b>children</b></td></tr>
<tr class="separator:a3df3d5bee8754d56741a72ffa9494fad"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-static-attribs" name="pro-static-attribs"></a>
Static Protected Attributes</h2></td></tr>
<tr class="memitem:aa9c20b49731438a3eb056454cfa52a20" id="r_aa9c20b49731438a3eb056454cfa52a20"><td class="memItemLeft" align="right" valign="top"><a id="aa9c20b49731438a3eb056454cfa52a20" name="aa9c20b49731438a3eb056454cfa52a20"></a>
static const <a class="el" href="classdrain_1_1DRAIN__TREE__NAME.html">tree_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>emptyNode</b></td></tr>
<tr class="separator:aa9c20b49731438a3eb056454cfa52a20"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;class T, bool EXCLUSIVE = false, class P = drain::Path&lt;std::string,'/'&gt;&gt;<br />
class drain::DRAIN_TREE_NAME&lt; T, EXCLUSIVE, P &gt;</div><p>A templated class for directed rooted trees. </p>
<p>This file provides templates of for basic types of trees (directed rooted trees):</p>
<ul>
<li>OrderedTree – std::map&lt;&gt;</li>
<li>OrderedMultiTree – std::multimap</li>
<li>UnorderedTree – std::list</li>
<li>UnorderedMultiTree – std::list</li>
</ul>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>- node type, containing user-designed data implementing <a class="el" href="classdrain_1_1DRAIN__TREE__NAME.html#ac8bb3912a3ce86b15842e79d0b421204" title="Clear children and node data.">clear()</a>, size() and <a class="el" href="classdrain_1_1DRAIN__TREE__NAME.html#a5dc9d7494d137f8725d90c21d037fe4a" title="Check if the tree structure is empty.">empty()</a> for future compatibility. </td></tr>
    <tr><td class="paramname">EXCLUSIVE</td><td>- node can contains either data or children but not both (JSON-like convention) </td></tr>
    <tr><td class="paramname">P</td><td>- applied path structure, like std::list – must implement <a class="el" href="classdrain_1_1DRAIN__TREE__NAME.html#a5dc9d7494d137f8725d90c21d037fe4a" title="Check if the tree structure is empty.">empty()</a> both for path and keys (path elements)</td></tr>
  </table>
  </dd>
</dl>
<p>Data:</p>
<p>The nodes in a tree contain user defined data, the type of which is given as template T.</p>
<p>Currenty, data Concept is requires the following methods:</p><ul>
<li><a class="el" href="classdrain_1_1DRAIN__TREE__NAME.html#ac8bb3912a3ce86b15842e79d0b421204" title="Clear children and node data.">clear()</a> – resetting the data to default initial (empty) value.</li>
<li><a class="el" href="classdrain_1_1DRAIN__TREE__NAME.html#a5dc9d7494d137f8725d90c21d037fe4a" title="Check if the tree structure is empty.">empty()</a> – returning true if the data is empty, or can be identified with empty.</li>
</ul>
<p>A tree is EXCLUSIVE, if a node contains either data or children. For example, a <a class="el" href="classdrain_1_1JSON.html" title="Utility for extracting JSON-compatible strings, numbers or arrays of numbers in text data.">JSON</a> tree is EXCLUSIVE and an <a class="el" href="classdrain_1_1XML.html" title="Base class for XML &quot;nodes&quot;, to be data elements T for drain::Tree&lt;T&gt;">XML</a> tree is not (a tag can containg attributes (data) and inner tages (children).</p>
<p>Further, each type listed above has two variants:</p><ul>
<li>inclusive (implicit, default) – each node may contain data and child nodes.</li>
<li>exclusive – each node may contain data or child nodes, but not both. In the code, both data and children exist as members but in exclusive trees data is automatically cleared if children are added, and inversely, chilren are cleared (removed) if data is assigned.</li>
</ul>
<p>Limitation: in OrderedTree the children are in a std::map, and threrefore each child of a node has a unique key. In UnorderedTree there may be children having the same key.</p>
<p>Addressing:</p>
<p>tree(&lt;path&gt;) return a descendant tree[&lt;path_element&gt;] returns childs only (complains separators, for some time)</p>
<p>Child nodes can be addressed with operator[] with std::string valued keys: </p><div class="fragment"><div class="line">OrderedTree&lt;std::string&gt; tree;</div>
<div class="line">t[<span class="stringliteral">&quot;first&quot;</span>] = <span class="stringliteral">&quot;Hello!&quot;</span>;</div>
<div class="line">t[<span class="stringliteral">&quot;second&quot;</span>] = <span class="stringliteral">&quot;Another greeting...&quot;</span>;</div>
</div><!-- fragment --><p>As the operator[] returns a reference, it may be used recursively: </p><div class="fragment"><div class="line">OrderedTree&lt;std::string&gt; &amp; subTree1 = t[<span class="stringliteral">&quot;first&quot;</span>][<span class="stringliteral">&quot;child&quot;</span>][<span class="stringliteral">&quot;grandChild&quot;</span>];</div>
</div><!-- fragment --><p>Tree also recognizes a path separator, which is '/' by default. Hence, the node created in the above example could be likewise created or addressed as: </p><div class="fragment"><div class="line">OrderedTree&lt;std::string&gt; &amp; subTree = t(<span class="stringliteral">&quot;first/child/grandChild&quot;</span>);        <span class="comment">// equivalent</span></div>
</div><!-- fragment --><p>One may iterate the children directly: </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp; entry: tree){</div>
<div class="line">  std::cout &lt;&lt; entry.first &lt;&lt; <span class="charliteral">&#39;:&#39;</span> &lt;&lt; entry.second &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Each node contains data of type T. It may be unused (empty), that is, a node can be used only as a branching point.</p>
<div class="fragment"><div class="line">OrderedTree&lt;std::string&gt; t;</div>
<div class="line">t.data = <span class="stringliteral">&quot;Hello world&quot;</span>;</div>
<div class="line">std::string s = t;  <span class="comment">// Now contains &quot;Hello world&quot;.</span></div>
</div><!-- fragment --><p> (Direct assignments to and from the node data has been supported, but is now <b>disabled</b> for c++ compatibility reasons.)</p>
<p>Also direct referencing of the node data is now <b>disabled:</b> </p><div class="fragment"><div class="line">Tree&lt;std::string&gt; t;</div>
<div class="line">t = <span class="stringliteral">&quot;Hello world&quot;</span>;</div>
<div class="line">Tree&lt;std::string&gt; &amp;r = t; <span class="comment">// Refers to tree.</span></div>
<div class="line">std::string &amp;s = t;       <span class="comment">// Refers to data, &quot;Hello world&quot;.</span></div>
</div><!-- fragment --><p>Obsolete: template C - path element comparison functor, should be compatible with Path&lt;P&gt;::key_t. #ifndef DRAIN_AMBIVALUE #define DRAIN_AMBIVALUE "0.1beta" template &lt;class T, class K&gt; class CombiValue { public: </p><pre class="fragment">typedef T data_t;
typedef K key_t;
</pre><p> T data; CONSIDER! But Hi5Node heavy? </p><pre class="fragment">inline
~CombiValue(){};
</pre><p> / True, if data is structured. virtual bool hasMultipleData() const = 0;</p>
<pre class="fragment">virtual
const data_t &amp; getData() const = 0;

virtual
data_t &amp; getData() = 0;

virtual
const data_t &amp; getData(const key_t &amp;) const = 0;

virtual
data_t &amp; getData(const key_t &amp;) = 0;
</pre><p> }; #endif </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">K</td><td>– key type </td></tr>
    <tr><td class="paramname">K</td><td>– key type </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a096ce1ab7533a296351b535765aadd3a" name="a096ce1ab7533a296351b535765aadd3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a096ce1ab7533a296351b535765aadd3a">&#9670;&#160;</a></span>addChild()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , bool EXCLUSIVE = false, class P  = drain::Path&lt;std::string,'/'&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classdrain_1_1DRAIN__TREE__NAME.html">tree_t</a> &amp; addChild </td>
          <td>(</td>
          <td class="paramtype">const key_t &amp;&#160;</td>
          <td class="paramname"><em>key</em> = <code>key_t()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a child node. If unordered and UNIQUE, reuse existing nodes. </p>
<p>Behaviour of this function varies as follows:</p>
<ul>
<li>OrderedTree: return child named <code>key</code>, if exists</li>
<li>UnorderedTree, UNIQUE==true: return the first child named <code>key</code>, if exists, else create one.</li>
<li>UnorderedTree, UNIQUE==false: always create a new child named <code>key</code> and return it. </li>
</ul>

</div>
</div>
<a id="ac8bb3912a3ce86b15842e79d0b421204" name="ac8bb3912a3ce86b15842e79d0b421204"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8bb3912a3ce86b15842e79d0b421204">&#9670;&#160;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , bool EXCLUSIVE = false, class P  = drain::Path&lt;std::string,'/'&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear children and node data. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrain_1_1DRAIN__TREE__NAME.html#aa3b723ff8f1045f2b4c2a8fae13c3989" title="Deletes a descendant node and hence its subtrees.">erase()</a> </dd>
<dd>
<a class="el" href="classdrain_1_1DRAIN__TREE__NAME.html#a091c6265950643e307d70411dab30bc7" title="Clears the children of this node. Does not clear data.">clearChildren()</a> </dd>
<dd>
<a class="el" href="classdrain_1_1DRAIN__TREE__NAME.html#abd4e5c937c4b98dd42745acb33815cdf">clearData()</a> </dd></dl>

</div>
</div>
<a id="a091c6265950643e307d70411dab30bc7" name="a091c6265950643e307d70411dab30bc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a091c6265950643e307d70411dab30bc7">&#9670;&#160;</a></span>clearChildren()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , bool EXCLUSIVE = false, class P  = drain::Path&lt;std::string,'/'&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void clearChildren </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clears the children of this node. Does not clear data. </p>
<p>x * </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrain_1_1DRAIN__TREE__NAME.html#abd4e5c937c4b98dd42745acb33815cdf">clearData()</a> </dd>
<dd>
<a class="el" href="classdrain_1_1DRAIN__TREE__NAME.html#ac8bb3912a3ce86b15842e79d0b421204" title="Clear children and node data.">clear()</a> </dd>
<dd>
<a class="el" href="classdrain_1_1DRAIN__TREE__NAME.html#aa3b723ff8f1045f2b4c2a8fae13c3989" title="Deletes a descendant node and hence its subtrees.">erase()</a> </dd></dl>

</div>
</div>
<a id="abd4e5c937c4b98dd42745acb33815cdf" name="abd4e5c937c4b98dd42745acb33815cdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd4e5c937c4b98dd42745acb33815cdf">&#9670;&#160;</a></span>clearData()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , bool EXCLUSIVE = false, class P  = drain::Path&lt;std::string,'/'&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void clearData </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrain_1_1DRAIN__TREE__NAME.html#ac8bb3912a3ce86b15842e79d0b421204" title="Clear children and node data.">clear()</a> </dd>
<dd>
<a class="el" href="classdrain_1_1DRAIN__TREE__NAME.html#a091c6265950643e307d70411dab30bc7" title="Clears the children of this node. Does not clear data.">clearChildren()</a> </dd>
<dd>
<a class="el" href="classdrain_1_1DRAIN__TREE__NAME.html#aa3b723ff8f1045f2b4c2a8fae13c3989" title="Deletes a descendant node and hence its subtrees.">erase()</a> </dd></dl>

</div>
</div>
<a id="aa3b723ff8f1045f2b4c2a8fae13c3989" name="aa3b723ff8f1045f2b4c2a8fae13c3989"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3b723ff8f1045f2b4c2a8fae13c3989">&#9670;&#160;</a></span>erase()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , bool EXCLUSIVE = false, class P  = drain::Path&lt;std::string,'/'&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void erase </td>
          <td>(</td>
          <td class="paramtype">const path_t &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deletes a descendant node and hence its subtrees. </p>
<p>As opposite of <a class="el" href="classdrain_1_1DRAIN__TREE__NAME.html#ac8bb3912a3ce86b15842e79d0b421204" title="Clear children and node data.">clear()</a> which focuses on a (current) node, this function refers to a descendant.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrain_1_1DRAIN__TREE__NAME.html#ac8bb3912a3ce86b15842e79d0b421204" title="Clear children and node data.">clear()</a> </dd></dl>

</div>
</div>
<a id="a1b34f007b6dcdf7090e2e49d370c86fa" name="a1b34f007b6dcdf7090e2e49d370c86fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b34f007b6dcdf7090e2e49d370c86fa">&#9670;&#160;</a></span>get()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , bool EXCLUSIVE = false, class P  = drain::Path&lt;std::string,'/'&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrain_1_1DRAIN__TREE__NAME.html">tree_t</a> &amp; get </td>
          <td>(</td>
          <td class="paramtype">typename path_t::const_iterator&#160;</td>
          <td class="paramname"><em>it</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename path_t::const_iterator&#160;</td>
          <td class="paramname"><em>eit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given the descendant pointed to by a given path segment. </p>
<dl class="section return"><dt>Returns</dt><dd>– descendant node, or the node itself if the path is empty. </dd></dl>

</div>
</div>
<a id="aa450468894c0ff2066310624173c0152" name="aa450468894c0ff2066310624173c0152"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa450468894c0ff2066310624173c0152">&#9670;&#160;</a></span>getChildren()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , bool EXCLUSIVE = false, class P  = drain::Path&lt;std::string,'/'&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">container_t &amp; getChildren </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the map containing the children. </p>
<p>This is useful for example for map::swap ? </p>

</div>
</div>
<a id="a47f00b880022a29d4000212fdd412ed4" name="a47f00b880022a29d4000212fdd412ed4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47f00b880022a29d4000212fdd412ed4">&#9670;&#160;</a></span>getEmpty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , bool EXCLUSIVE = false, class P  = drain::Path&lt;std::string,'/'&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="classdrain_1_1DRAIN__TREE__NAME.html">tree_t</a> &amp; getEmpty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>GENERAL (independent from container type) Empty "default" node; typically initialized with empty data as well. </p>

</div>
</div>
<a id="ac729ceb49af576a8ddac20f4bb8e3f45" name="ac729ceb49af576a8ddac20f4bb8e3f45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac729ceb49af576a8ddac20f4bb8e3f45">&#9670;&#160;</a></span>hasChild()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , bool EXCLUSIVE = false, class P  = drain::Path&lt;std::string,'/'&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool hasChild </td>
          <td>(</td>
          <td class="paramtype">const key_t &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the tree node has a direct descendant with name <code>key</code>. </p>
<p>A multiple tree may have more than one children with the same name. With them, consider hasChildren(const key_t &amp;key) . </p><dl class="section see"><dt>See also</dt><dd>OrderedMultiTree </dd>
<dd>
UnorderedMultiTree</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>– the number of children with name 'key'. </dd></dl>

</div>
</div>
<a id="a005a8565608b53d552ed49c05a9e3361" name="a005a8565608b53d552ed49c05a9e3361"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a005a8565608b53d552ed49c05a9e3361">&#9670;&#160;</a></span>hasChildren()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , bool EXCLUSIVE = false, class P  = drain::Path&lt;std::string,'/'&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int hasChildren </td>
          <td>(</td>
          <td class="paramtype">const key_t &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The number of children with name key. </p>
<p>Checks how many immediate descendants with name <code>key</code> exist.</p>
<p>A multiple tree may have more than one children with the same name. </p><dl class="section see"><dt>See also</dt><dd>OrderedMultiTree, UnorderedMultiTree</dd></dl>
<p>With simple trees, use the faster hasChild(const key_t &amp;key). </p><dl class="section see"><dt>See also</dt><dd>OrderedTree </dd>
<dd>
UnorderedTree.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>– the number of children with name 'key'. </dd></dl>

</div>
</div>
<a id="a91080c09ebdb9bd501d9c244aec87d7a" name="a91080c09ebdb9bd501d9c244aec87d7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91080c09ebdb9bd501d9c244aec87d7a">&#9670;&#160;</a></span>hasPath()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , bool EXCLUSIVE = false, class P  = drain::Path&lt;std::string,'/'&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool hasPath </td>
          <td>(</td>
          <td class="paramtype">typename path_t::const_iterator&#160;</td>
          <td class="paramname"><em>it</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename path_t::const_iterator&#160;</td>
          <td class="paramname"><em>eit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>"Default implementation" of key conversion – the identity mapping. </p>
<p>Conversion of char array to key type, which itself should never be a char array. Mapping of keys of external type - for example an enumerated type - to native <code>key_t</code> type. Checks if there is a node with a given path name. Could be called hasDescendant; hence is like <a class="el" href="classdrain_1_1DRAIN__TREE__NAME.html#ac729ceb49af576a8ddac20f4bb8e3f45" title="Check if the tree node has a direct descendant with name key.">hasChild()</a> but calls children recursively.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">eit</td><td>- <a class="el" href="classdrain_1_1DRAIN__TREE__NAME.html#acdbe1b3241957d4062ec8683399520a4" title="Child iterator end.">end()</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a474445bff1b6006c536048878860f80b" name="a474445bff1b6006c536048878860f80b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a474445bff1b6006c536048878860f80b">&#9670;&#160;</a></span>operator()() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , bool EXCLUSIVE = false, class P  = drain::Path&lt;std::string,'/'&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrain_1_1DRAIN__TREE__NAME.html">tree_t</a> &amp; operator() </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Redirects the call to operator()(const std::string &amp; arg) . </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arg</td><td>- by default, the path from the current node to the child node. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae42dc21078ae07664553b21bf2a294fb" name="ae42dc21078ae07664553b21bf2a294fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae42dc21078ae07664553b21bf2a294fb">&#9670;&#160;</a></span>operator()() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , bool EXCLUSIVE = false, class P  = drain::Path&lt;std::string,'/'&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrain_1_1DRAIN__TREE__NAME.html">tree_t</a> &amp; operator() </td>
          <td>(</td>
          <td class="paramtype">const path_t &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a descendant. Creates one if not existing already. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>- the path from the current node to the child node.</td></tr>
  </table>
  </dd>
</dl>
<p>This function, using native path_t type, should be reserved for this semantic by not redefining (specialising) this function in template classes. </p>

</div>
</div>
<a id="a52ff5144d38c35429c32a7aab8289845" name="a52ff5144d38c35429c32a7aab8289845"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52ff5144d38c35429c32a7aab8289845">&#9670;&#160;</a></span>operator()() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , bool EXCLUSIVE = false, class P  = drain::Path&lt;std::string,'/'&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrain_1_1DRAIN__TREE__NAME.html">tree_t</a> &amp; operator() </td>
          <td>(</td>
          <td class="paramtype">const path_t &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a descendant if that exists, else returns an empty node. Otherwise like non-const counterpart. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>- the path from the current node to the child node.</td></tr>
  </table>
  </dd>
</dl>
<p>This function, using <em>native</em> path_t type, should be reserved for this semantic by not redefining (specialising) this function in template classes. </p>

</div>
</div>
<a id="ab35f42633928b482d9ef2fea4fc9f2c8" name="ab35f42633928b482d9ef2fea4fc9f2c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab35f42633928b482d9ef2fea4fc9f2c8">&#9670;&#160;</a></span>operator()() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , bool EXCLUSIVE = false, class P  = drain::Path&lt;std::string,'/'&gt;&gt; </div>
<div class="memtemplate">
template&lt;class S &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrain_1_1DRAIN__TREE__NAME.html">tree_t</a> &amp; operator() </td>
          <td>(</td>
          <td class="paramtype">const S &amp;&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a descendant. Creates one if not existing already. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>- the path from the current node to the child node.</td></tr>
  </table>
  </dd>
</dl>
<p>This function, not using native path_t type, can be redefined in template classes. For example, an important attribute can be set using this method.</p>
<p>However, <a class="el" href="classdrain_1_1DRAIN__TREE__NAME.html#a474445bff1b6006c536048878860f80b" title="Redirects the call to operator()(const std::string &amp; arg) .">operator()(const char *arg)</a> should be redefined to produce equivalent result with <code>const string &amp;arg</code>. </p>

</div>
</div>
<a id="a3cdae6a828244f1c0d536ed626920f06" name="a3cdae6a828244f1c0d536ed626920f06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cdae6a828244f1c0d536ed626920f06">&#9670;&#160;</a></span>operator=() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , bool EXCLUSIVE = false, class P  = drain::Path&lt;std::string,'/'&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrain_1_1DRAIN__TREE__NAME.html">tree_t</a> &amp; operator= </td>
          <td>(</td>
          <td class="paramtype">const std::initializer_list&lt; V &gt; &amp;&#160;</td>
          <td class="paramname"><em>l</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign data. </p>
<p>If init list elements are not pairs, assign it to node data.</p>
<p>2025/01 experimental. </p>

</div>
</div>
<a id="a9b112726e65b27df1258160ad59c7fa9" name="a9b112726e65b27df1258160ad59c7fa9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b112726e65b27df1258160ad59c7fa9">&#9670;&#160;</a></span>operator=() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , bool EXCLUSIVE = false, class P  = drain::Path&lt;std::string,'/'&gt;&gt; </div>
<div class="memtemplate">
template&lt;class T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrain_1_1DRAIN__TREE__NAME.html">tree_t</a> &amp; operator= </td>
          <td>(</td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assigns value to contents. </p>
<p>Assigns a value to contents. This may be redefined in derived classes. For example, assigning a value of certain class may cause adding a specific child element instead of assigning to data (the default, here). </p>

</div>
</div>
<a id="a2aec2b27c82ec45ce0f006cb62f85bf2" name="a2aec2b27c82ec45ce0f006cb62f85bf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2aec2b27c82ec45ce0f006cb62f85bf2">&#9670;&#160;</a></span>operator=() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , bool EXCLUSIVE = false, class P  = drain::Path&lt;std::string,'/'&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrain_1_1DRAIN__TREE__NAME.html">tree_t</a> &amp; operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrain_1_1DRAIN__TREE__NAME.html">tree_t</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the data of another node. Does not copy the children. </p>
<p>Default use to reset a node (re-initialize its data). </p>

</div>
</div>
<a id="af682d01b973b014c8b745eb0b183a77f" name="af682d01b973b014c8b745eb0b183a77f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af682d01b973b014c8b745eb0b183a77f">&#9670;&#160;</a></span>operator=() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , bool EXCLUSIVE = false, class P  = drain::Path&lt;std::string,'/'&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrain_1_1DRAIN__TREE__NAME.html">tree_t</a> &amp; operator= </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; std::pair&lt; const char *, const <a class="el" href="namespacedrain.html#ab7d12e28978bddd9b2fda7142a1c0420">Variable</a> &gt; &gt;&#160;</td>
          <td class="paramname"><em>l</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign tree structure (of depth one). </p>
<p>Default implementation: assign new nodes (children).</p>
<p>Examples of overriding:</p><ul>
<li>TreeXML::operator=()</li>
<li>TreeSVG::operator=() </li>
</ul>

</div>
</div>
<a id="a63826658ff44573948e9ec387448681f" name="a63826658ff44573948e9ec387448681f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63826658ff44573948e9ec387448681f">&#9670;&#160;</a></span>operator=() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , bool EXCLUSIVE = false, class P  = drain::Path&lt;std::string,'/'&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrain_1_1DRAIN__TREE__NAME.html">tree_t</a> &amp; operator= </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; std::pair&lt; K, V &gt; &gt;&#160;</td>
          <td class="paramname"><em>l</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign tree structure (of depth one). </p>
<p>Default implementation: assign new nodes (children). </p>

</div>
</div>
<a id="a0cc2f3512809bfa39f7bddec594be2f4" name="a0cc2f3512809bfa39f7bddec594be2f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cc2f3512809bfa39f7bddec594be2f4">&#9670;&#160;</a></span>operator[]()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , bool EXCLUSIVE = false, class P  = drain::Path&lt;std::string,'/'&gt;&gt; </div>
<div class="memtemplate">
template&lt;class K &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrain_1_1DRAIN__TREE__NAME.html">tree_t</a> &amp; operator[] </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>NEW 2025 templated child addressing operator. </p>
<p>Allows using <a class="el" href="structdrain_1_1EnumDict.html" title="A container for a static dictionary of enumeration values.">EnumDict</a> enums as keys, for example. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src/drain/util/<a class="el" href="Tree_8h_source.html">Tree.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.17-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.9.8
</small></address>
</body>
</html>
