<!-- HTML header for doxygen 1.8.17-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>rack: SmartMapFoo&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="rack.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="rack-logo-110x55.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname"><!-- rack /-->
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacedrain.html">drain</a></li><li class="navelem"><a class="el" href="classdrain_1_1SmartMapFoo.html">SmartMapFoo</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classdrain_1_1SmartMapFoo-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">SmartMapFoo&lt; T &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A base class for smart maps providing methods for importing and exporting values, among others.  
 <a href="classdrain_1_1SmartMapFoo.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="SmartMap2_8h_source.html">SmartMap2.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for SmartMapFoo&lt; T &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classdrain_1_1SmartMapFoo__inherit__graph.png" border="0" usemap="#aSmartMapFoo_3_01T_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="aSmartMapFoo_3_01T_01_4_inherit__map" id="aSmartMapFoo_3_01T_01_4_inherit__map">
<area shape="rect" title="A base class for smart maps providing methods for importing and exporting values, among others." alt="" coords="11,80,162,107"/>
<area shape="rect" title=" " alt="" coords="5,5,168,32"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for SmartMapFoo&lt; T &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classdrain_1_1SmartMapFoo__coll__graph.png" border="0" usemap="#aSmartMapFoo_3_01T_01_4_coll__map" alt="Collaboration graph"/></div>
<map name="aSmartMapFoo_3_01T_01_4_coll__map" id="aSmartMapFoo_3_01T_01_4_coll__map">
<area shape="rect" title="A base class for smart maps providing methods for importing and exporting values, among others." alt="" coords="11,80,162,107"/>
<area shape="rect" title=" " alt="" coords="5,5,168,32"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a57d0862c00db1ecc14210cc5c981b62a"><td class="memItemLeft" align="right" valign="top"><a id="a57d0862c00db1ecc14210cc5c981b62a"></a>
typedef <a class="el" href="classdrain_1_1SmartMapFoo.html">SmartMapFoo</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>smap_t</b></td></tr>
<tr class="separator:a57d0862c00db1ecc14210cc5c981b62a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b94410f67a58121dba70f1031c4ba43"><td class="memItemLeft" align="right" valign="top"><a id="a5b94410f67a58121dba70f1031c4ba43"></a>
typedef std::map&lt; std::string, T &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>map_t</b></td></tr>
<tr class="separator:a5b94410f67a58121dba70f1031c4ba43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64646a187ac923aa5d6ba4d69226c3d8"><td class="memItemLeft" align="right" valign="top"><a id="a64646a187ac923aa5d6ba4d69226c3d8"></a>
typedef map_t::key_type&#160;</td><td class="memItemRight" valign="bottom"><b>key_t</b></td></tr>
<tr class="separator:a64646a187ac923aa5d6ba4d69226c3d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d3784ffe3470e4332d29991f9094791"><td class="memItemLeft" align="right" valign="top"><a id="a2d3784ffe3470e4332d29991f9094791"></a>
typedef map_t::mapped_type&#160;</td><td class="memItemRight" valign="bottom"><b>value_t</b></td></tr>
<tr class="separator:a2d3784ffe3470e4332d29991f9094791"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20ace51330c543522edd91ed93bdcd0a"><td class="memItemLeft" align="right" valign="top"><a id="a20ace51330c543522edd91ed93bdcd0a"></a>
typedef map_t::value_type&#160;</td><td class="memItemRight" valign="bottom"><b>entry_t</b></td></tr>
<tr class="separator:a20ace51330c543522edd91ed93bdcd0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36b214ba86026bdad0ee8573d26f87cb"><td class="memItemLeft" align="right" valign="top"><a id="a36b214ba86026bdad0ee8573d26f87cb"></a>
typedef std::list&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>keylist_t</b></td></tr>
<tr class="separator:a36b214ba86026bdad0ee8573d26f87cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02720ab92b997d08a475408a87a9a378"><td class="memItemLeft" align="right" valign="top"><a id="a02720ab92b997d08a475408a87a9a378"></a>
typedef map_t::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrain_1_1SmartMapFoo.html#a02720ab92b997d08a475408a87a9a378">iterator</a></td></tr>
<tr class="memdesc:a02720ab92b997d08a475408a87a9a378"><td class="mdescLeft">&#160;</td><td class="mdescRight">Needed? <br /></td></tr>
<tr class="separator:a02720ab92b997d08a475408a87a9a378"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b1044fb589ffa9451ee2a57f7649293"><td class="memItemLeft" align="right" valign="top"><a id="a1b1044fb589ffa9451ee2a57f7649293"></a>
typedef map_t::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>const_iterator</b></td></tr>
<tr class="separator:a1b1044fb589ffa9451ee2a57f7649293"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a3f08f13f032abf160d25ca6f126afb7e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrain_1_1SmartMapFoo.html#a3f08f13f032abf160d25ca6f126afb7e">SmartMapFoo</a> (char <a class="el" href="classdrain_1_1SmartMapFoo.html#a6989953791434c8ea982054551c9e154">separator</a>='\0', char <a class="el" href="classdrain_1_1SmartMapFoo.html#a360531fdf0529252ca32fe16010bab62">arraySeparator</a>=':')</td></tr>
<tr class="separator:a3f08f13f032abf160d25ca6f126afb7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacfb22d39686d25da476bd1875da916b"><td class="memItemLeft" align="right" valign="top"><a id="aacfb22d39686d25da476bd1875da916b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SmartMapFoo</b> (const <a class="el" href="classdrain_1_1SmartMapFoo.html">SmartMapFoo</a> &amp;smap)</td></tr>
<tr class="separator:aacfb22d39686d25da476bd1875da916b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae048282c7011eedc2e0492f6421ea73"><td class="memItemLeft" align="right" valign="top"><a id="aae048282c7011eedc2e0492f6421ea73"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>clear</b> ()</td></tr>
<tr class="separator:aae048282c7011eedc2e0492f6421ea73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2caa6fea9e9725a1d3dde96af1e1ff9"><td class="memItemLeft" align="right" valign="top"><a id="ad2caa6fea9e9725a1d3dde96af1e1ff9"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>hasKey</b> (const std::string &amp;key) const</td></tr>
<tr class="separator:ad2caa6fea9e9725a1d3dde96af1e1ff9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe464e25c8f6b69f9fc017b58427fc87"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrain_1_1SmartMapFoo.html#abe464e25c8f6b69f9fc017b58427fc87">get</a> (const std::string &amp;key, const std::string &amp;defaultValue) const</td></tr>
<tr class="memdesc:abe464e25c8f6b69f9fc017b58427fc87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves a value, or default value if value is unset.  <a href="classdrain_1_1SmartMapFoo.html#abe464e25c8f6b69f9fc017b58427fc87">More...</a><br /></td></tr>
<tr class="separator:abe464e25c8f6b69f9fc017b58427fc87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8390a381c0b062fc137f5ff60b107bce"><td class="memItemLeft" align="right" valign="top"><a id="a8390a381c0b062fc137f5ff60b107bce"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>get</b> (const std::string &amp;key, const char *defaultValue) const</td></tr>
<tr class="separator:a8390a381c0b062fc137f5ff60b107bce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad74a85c5bd84d0e91503916724287f1b"><td class="memTemplParams" colspan="2">template&lt;class T2 &gt; </td></tr>
<tr class="memitem:ad74a85c5bd84d0e91503916724287f1b"><td class="memTemplItemLeft" align="right" valign="top">T2&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrain_1_1SmartMapFoo.html#ad74a85c5bd84d0e91503916724287f1b">get</a> (const std::string &amp;key, T2 defaultValue) const</td></tr>
<tr class="memdesc:ad74a85c5bd84d0e91503916724287f1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves a value, if set, else returns the given default value.  <a href="classdrain_1_1SmartMapFoo.html#ad74a85c5bd84d0e91503916724287f1b">More...</a><br /></td></tr>
<tr class="separator:ad74a85c5bd84d0e91503916724287f1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1899a31da0f3cf23bbd08b6c2ed88052"><td class="memItemLeft" align="right" valign="top">virtual T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrain_1_1SmartMapFoo.html#a1899a31da0f3cf23bbd08b6c2ed88052">operator[]</a> (const std::string &amp;key)</td></tr>
<tr class="memdesc:a1899a31da0f3cf23bbd08b6c2ed88052"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an element. Creates one, conditionally.  <a href="classdrain_1_1SmartMapFoo.html#a1899a31da0f3cf23bbd08b6c2ed88052">More...</a><br /></td></tr>
<tr class="separator:a1899a31da0f3cf23bbd08b6c2ed88052"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37ab9e853139558bebadaca3f7aed510"><td class="memItemLeft" align="right" valign="top"><a id="a37ab9e853139558bebadaca3f7aed510"></a>
virtual const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrain_1_1SmartMapFoo.html#a37ab9e853139558bebadaca3f7aed510">operator[]</a> (const std::string &amp;key) const</td></tr>
<tr class="memdesc:a37ab9e853139558bebadaca3f7aed510"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlike with std::map, operator[] const is defined, returning reference to a static empty instance. <br /></td></tr>
<tr class="separator:a37ab9e853139558bebadaca3f7aed510"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8df04dbdd0242338d5b4aa4cfbcc6d93"><td class="memItemLeft" align="right" valign="top"><a id="a8df04dbdd0242338d5b4aa4cfbcc6d93"></a>
virtual const keylist_t &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrain_1_1SmartMapFoo.html#a8df04dbdd0242338d5b4aa4cfbcc6d93">getKeyList</a> () const</td></tr>
<tr class="memdesc:a8df04dbdd0242338d5b4aa4cfbcc6d93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Derived versions may produce an ordered set of keys. <br /></td></tr>
<tr class="separator:a8df04dbdd0242338d5b4aa4cfbcc6d93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec212d2efc6953ef797b2db678e7ec43"><td class="memItemLeft" align="right" valign="top">const map_t &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrain_1_1SmartMapFoo.html#aec212d2efc6953ef797b2db678e7ec43">getMap</a> () const</td></tr>
<tr class="separator:aec212d2efc6953ef797b2db678e7ec43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2d8c7c53beee48e997af82bfed2add4"><td class="memTemplParams" colspan="2"><a id="aa2d8c7c53beee48e997af82bfed2add4"></a>
template&lt;class T2 &gt; </td></tr>
<tr class="memitem:aa2d8c7c53beee48e997af82bfed2add4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrain_1_1SmartMapFoo.html#aa2d8c7c53beee48e997af82bfed2add4">exportMap</a> (std::map&lt; std::string, T2 &gt; &amp;m) const</td></tr>
<tr class="memdesc:aa2d8c7c53beee48e997af82bfed2add4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the contents to another map. <br /></td></tr>
<tr class="separator:aa2d8c7c53beee48e997af82bfed2add4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f8a191f70ea2b677bc6d242d497e4d7"><td class="memTemplParams" colspan="2">template&lt;bool STRICT = true&gt; </td></tr>
<tr class="memitem:a1f8a191f70ea2b677bc6d242d497e4d7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrain_1_1SmartMapFoo.html#a1f8a191f70ea2b677bc6d242d497e4d7">importEntries</a> (const std::string &amp;entries, char assignmentSymbol='=', char separatorSymbol=0)</td></tr>
<tr class="memdesc:a1f8a191f70ea2b677bc6d242d497e4d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns a value to given key; if the entry does not exist, tries to create it with directly with operator[].  <a href="classdrain_1_1SmartMapFoo.html#a1f8a191f70ea2b677bc6d242d497e4d7">More...</a><br /></td></tr>
<tr class="separator:a1f8a191f70ea2b677bc6d242d497e4d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eb0e92e99282aa01b5fd0f68b9881d3"><td class="memTemplParams" colspan="2">template&lt;bool STRICT = true&gt; </td></tr>
<tr class="memitem:a5eb0e92e99282aa01b5fd0f68b9881d3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrain_1_1SmartMapFoo.html#a5eb0e92e99282aa01b5fd0f68b9881d3">importEntries</a> (const std::list&lt; std::string &gt; &amp;entries, char assignmentSymbol='=')</td></tr>
<tr class="separator:a5eb0e92e99282aa01b5fd0f68b9881d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af96c05d0eecedaf1550432f0b74eb304"><td class="memTemplParams" colspan="2">template&lt;class S , bool STRICT = true&gt; </td></tr>
<tr class="memitem:af96c05d0eecedaf1550432f0b74eb304"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrain_1_1SmartMapFoo.html#af96c05d0eecedaf1550432f0b74eb304">importMap</a> (const std::map&lt; std::string, S &gt; &amp;m)</td></tr>
<tr class="memdesc:af96c05d0eecedaf1550432f0b74eb304"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign values from a map, overriding existing entries.  <a href="classdrain_1_1SmartMapFoo.html#af96c05d0eecedaf1550432f0b74eb304">More...</a><br /></td></tr>
<tr class="separator:af96c05d0eecedaf1550432f0b74eb304"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dfbff0fda4c400c3edcd0ae920f573d"><td class="memTemplParams" colspan="2">template&lt;class T2 , bool STRICT = true&gt; </td></tr>
<tr class="memitem:a8dfbff0fda4c400c3edcd0ae920f573d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrain_1_1SmartMapFoo.html#a8dfbff0fda4c400c3edcd0ae920f573d">importCastableMap</a> (const <a class="el" href="classdrain_1_1SmartMap.html">drain::SmartMap</a>&lt; T2 &gt; &amp;m)</td></tr>
<tr class="memdesc:a8dfbff0fda4c400c3edcd0ae920f573d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign values from a map, possibly extending the map.  <a href="classdrain_1_1SmartMapFoo.html#a8dfbff0fda4c400c3edcd0ae920f573d">More...</a><br /></td></tr>
<tr class="separator:a8dfbff0fda4c400c3edcd0ae920f573d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3c45b7f1a61f1fbdc052cb4c6fb0c6d"><td class="memTemplParams" colspan="2">template&lt;class T2 &gt; </td></tr>
<tr class="memitem:ab3c45b7f1a61f1fbdc052cb4c6fb0c6d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrain_1_1SmartMapFoo.html#ab3c45b7f1a61f1fbdc052cb4c6fb0c6d">updateFromMap</a> (const std::map&lt; std::string, T2 &gt; &amp;m)</td></tr>
<tr class="memdesc:ab3c45b7f1a61f1fbdc052cb4c6fb0c6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign values from a map. Updates existing entries only.  <a href="classdrain_1_1SmartMapFoo.html#ab3c45b7f1a61f1fbdc052cb4c6fb0c6d">More...</a><br /></td></tr>
<tr class="separator:ab3c45b7f1a61f1fbdc052cb4c6fb0c6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45d85fa4be94ad41ea7f02fee0bd2f7c"><td class="memTemplParams" colspan="2"><a id="a45d85fa4be94ad41ea7f02fee0bd2f7c"></a>
template&lt;class T2 &gt; </td></tr>
<tr class="memitem:a45d85fa4be94ad41ea7f02fee0bd2f7c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrain_1_1SmartMapFoo.html#a45d85fa4be94ad41ea7f02fee0bd2f7c">updateFromCastableMap</a> (const <a class="el" href="classdrain_1_1SmartMapFoo.html">drain::SmartMapFoo</a>&lt; T2 &gt; &amp;m)</td></tr>
<tr class="memdesc:a45d85fa4be94ad41ea7f02fee0bd2f7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience. <br /></td></tr>
<tr class="separator:a45d85fa4be94ad41ea7f02fee0bd2f7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73dcba50de9c1b71d3daf5d10dbd30de"><td class="memItemLeft" align="right" valign="top"><a id="a73dcba50de9c1b71d3daf5d10dbd30de"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrain_1_1SmartMapFoo.html#a73dcba50de9c1b71d3daf5d10dbd30de">setValues</a> (const std::string &amp;entries, char assignmentSymbol='=', char separatorSymbol=0)</td></tr>
<tr class="memdesc:a73dcba50de9c1b71d3daf5d10dbd30de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets values. If strictness==STRICTLY_CLOSED, throws exception if tries to assign a non-existing entry. <br /></td></tr>
<tr class="separator:a73dcba50de9c1b71d3daf5d10dbd30de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a887f398f0ca56f8d6884a70129cfaccf"><td class="memItemLeft" align="right" valign="top"><a id="a887f398f0ca56f8d6884a70129cfaccf"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setValues</b> (const char *entries, char assignmentSymbol='=', char separatorSymbol=0)</td></tr>
<tr class="separator:a887f398f0ca56f8d6884a70129cfaccf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5660ab0d6690eb8d2bfdaf485d3f1f39"><td class="memTemplParams" colspan="2"><a id="a5660ab0d6690eb8d2bfdaf485d3f1f39"></a>
template&lt;class S &gt; </td></tr>
<tr class="memitem:a5660ab0d6690eb8d2bfdaf485d3f1f39"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>setValuesSEQ</b> (const S &amp;sequence)</td></tr>
<tr class="separator:a5660ab0d6690eb8d2bfdaf485d3f1f39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb5f415587d1a50e49ab7bdd37c6cdd7"><td class="memItemLeft" align="right" valign="top"><a id="abb5f415587d1a50e49ab7bdd37c6cdd7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrain_1_1SmartMapFoo.html#abb5f415587d1a50e49ab7bdd37c6cdd7">updateValues</a> (const std::string &amp;entries, char assignmentSymbol='=', char separatorSymbol=0)</td></tr>
<tr class="memdesc:abb5f415587d1a50e49ab7bdd37c6cdd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets applicable values ie. modifies existing entries only. In ordered maps, skips extra entries silently. <br /></td></tr>
<tr class="separator:abb5f415587d1a50e49ab7bdd37c6cdd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeff55d77dcee78a3600e0fa9ae9ee33b"><td class="memItemLeft" align="right" valign="top"><a id="aeff55d77dcee78a3600e0fa9ae9ee33b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>getKeys</b> (std::ostream &amp;ostr) const</td></tr>
<tr class="separator:aeff55d77dcee78a3600e0fa9ae9ee33b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a3f556fbd19992ce4b7ac80fb957910"><td class="memItemLeft" align="right" valign="top"><a id="a3a3f556fbd19992ce4b7ac80fb957910"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrain_1_1SmartMapFoo.html#a3a3f556fbd19992ce4b7ac80fb957910">getKeys</a> () const</td></tr>
<tr class="memdesc:a3a3f556fbd19992ce4b7ac80fb957910"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function for std::string output. <br /></td></tr>
<tr class="separator:a3a3f556fbd19992ce4b7ac80fb957910"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac46d54856697c46a1e49e6567004fc0"><td class="memItemLeft" align="right" valign="top"><a id="aac46d54856697c46a1e49e6567004fc0"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrain_1_1SmartMapFoo.html#aac46d54856697c46a1e49e6567004fc0">getValues</a> (std::ostream &amp;ostr) const</td></tr>
<tr class="memdesc:aac46d54856697c46a1e49e6567004fc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dumps the values. <br /></td></tr>
<tr class="separator:aac46d54856697c46a1e49e6567004fc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa01b686e5a02568f77baaeee981665d2"><td class="memItemLeft" align="right" valign="top"><a id="aa01b686e5a02568f77baaeee981665d2"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrain_1_1SmartMapFoo.html#aa01b686e5a02568f77baaeee981665d2">getValues</a> () const</td></tr>
<tr class="memdesc:aa01b686e5a02568f77baaeee981665d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function for std::string output. <br /></td></tr>
<tr class="separator:aa01b686e5a02568f77baaeee981665d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6364b0f03e6ab707dc9913e41775e7fe"><td class="memItemLeft" align="right" valign="top"><a id="a6364b0f03e6ab707dc9913e41775e7fe"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrain_1_1SmartMapFoo.html#a6364b0f03e6ab707dc9913e41775e7fe">toStream</a> (std::ostream &amp;ostr, char equal='=', char startChar='{', char endChar='}', char separatorChar=',') const</td></tr>
<tr class="memdesc:a6364b0f03e6ab707dc9913e41775e7fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Note: parameters discarded. <br /></td></tr>
<tr class="separator:a6364b0f03e6ab707dc9913e41775e7fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6370f2f2d1a59ba8c4b1170a63c8ae1e"><td class="memItemLeft" align="right" valign="top"><a id="a6370f2f2d1a59ba8c4b1170a63c8ae1e"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>toStr</b> (char equal='=', char start=0, char end=0, char <a class="el" href="classdrain_1_1SmartMapFoo.html#a6989953791434c8ea982054551c9e154">separator</a>=0) const</td></tr>
<tr class="separator:a6370f2f2d1a59ba8c4b1170a63c8ae1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2236179b2770b16ac72abb636634efd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrain_1_1SmartMapFoo.html#ac2236179b2770b16ac72abb636634efd">dump</a> (std::ostream &amp;ostr=std::cout) const</td></tr>
<tr class="memdesc:ac2236179b2770b16ac72abb636634efd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write map as a <a class="el" href="classdrain_1_1JSON.html" title="Utility for extracting JSON-compatible strings, numbers or arrays of numbers in text data.">JSON</a> code.  <a href="classdrain_1_1SmartMapFoo.html#ac2236179b2770b16ac72abb636634efd">More...</a><br /></td></tr>
<tr class="separator:ac2236179b2770b16ac72abb636634efd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a6989953791434c8ea982054551c9e154"><td class="memItemLeft" align="right" valign="top"><a id="a6989953791434c8ea982054551c9e154"></a>
char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrain_1_1SmartMapFoo.html#a6989953791434c8ea982054551c9e154">separator</a></td></tr>
<tr class="memdesc:a6989953791434c8ea982054551c9e154"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default character used for splitting input and output. See setValues. <br /></td></tr>
<tr class="separator:a6989953791434c8ea982054551c9e154"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a360531fdf0529252ca32fe16010bab62"><td class="memItemLeft" align="right" valign="top"><a id="a360531fdf0529252ca32fe16010bab62"></a>
char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrain_1_1SmartMapFoo.html#a360531fdf0529252ca32fe16010bab62">arraySeparator</a></td></tr>
<tr class="memdesc:a360531fdf0529252ca32fe16010bab62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default separator character for array elements (std::vector's) <br /></td></tr>
<tr class="separator:a360531fdf0529252ca32fe16010bab62"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a3e9d8363daba3503121bd79ad72093b0"><td class="memItemLeft" align="right" valign="top">std::list&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrain_1_1SmartMapFoo.html#a3e9d8363daba3503121bd79ad72093b0">keyList</a></td></tr>
<tr class="memdesc:a3e9d8363daba3503121bd79ad72093b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns values from std::string of type "value,value2,...valueN".  <a href="classdrain_1_1SmartMapFoo.html#a3e9d8363daba3503121bd79ad72093b0">More...</a><br /></td></tr>
<tr class="separator:a3e9d8363daba3503121bd79ad72093b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class T&gt;<br />
class drain::SmartMapFoo&lt; T &gt;</h3>

<p>A base class for smart maps providing methods for importing and exporting values, among others. </p>
<p>Unlike with std::map&lt;&gt;, operator[] is defined as const, too, returning reference to a static empty instance.</p>
<p><a class="el" href="classdrain_1_1SmartMap.html" title="A base class for smart maps providing methods for importing and exporting values, among others.">SmartMap</a> maintains an ordered list of keys, accessible with getKeys(). The items in the key list are appended in the order they have been created. This is order is generally different from the (alphabetical) order appearing in std::map iteration.</p>
<p>Comma-separated values can be assigned simultaneously with <a class="el" href="classdrain_1_1SmartMapFoo.html#a73dcba50de9c1b71d3daf5d10dbd30de" title="Sets values. If strictness==STRICTLY_CLOSED, throws exception if tries to assign a non-existing entry...">setValues()</a> and <a class="el" href="classdrain_1_1SmartMapFoo.html#abb5f415587d1a50e49ab7bdd37c6cdd7" title="Sets applicable values ie. modifies existing entries only. In ordered maps, skips extra entries silen...">updateValues()</a> </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a3f08f13f032abf160d25ca6f126afb7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f08f13f032abf160d25ca6f126afb7e">&#9670;&nbsp;</a></span>SmartMapFoo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrain_1_1SmartMapFoo.html">SmartMapFoo</a> </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>separator</em> = <code>'\0'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>arraySeparator</em> = <code>':'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">separator</td><td>- default character used for splitting input and output. See setValues </td></tr>
    <tr><td class="paramname">arraySeparator</td><td>- default character for inner elements that are array (std::vector's) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ac2236179b2770b16ac72abb636634efd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2236179b2770b16ac72abb636634efd">&#9670;&nbsp;</a></span>dump()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dump </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>ostr</em> = <code>std::cout</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write map as a <a class="el" href="classdrain_1_1JSON.html" title="Utility for extracting JSON-compatible strings, numbers or arrays of numbers in text data.">JSON</a> code. </p>
<p>Write map as a <a class="el" href="classdrain_1_1JSON.html" title="Utility for extracting JSON-compatible strings, numbers or arrays of numbers in text data.">JSON</a> code (array or scalar) Debugging </p>

</div>
</div>
<a id="abe464e25c8f6b69f9fc017b58427fc87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe464e25c8f6b69f9fc017b58427fc87">&#9670;&nbsp;</a></span>get() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string get </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>defaultValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves a value, or default value if value is unset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>- name of the variable </td></tr>
    <tr><td class="paramname">defaultValue</td><td>- the value to be returned if the variable is unset </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>- the value, if set; else the default value. </dd></dl>

</div>
</div>
<a id="ad74a85c5bd84d0e91503916724287f1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad74a85c5bd84d0e91503916724287f1b">&#9670;&nbsp;</a></span>get() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T2 get </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T2&#160;</td>
          <td class="paramname"><em>defaultValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves a value, if set, else returns the given default value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>- name of the variable </td></tr>
    <tr><td class="paramname">defaultValue</td><td>- the value to be returned if the variable is unset </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>- the value, if set; else the default value. </dd></dl>

</div>
</div>
<a id="aec212d2efc6953ef797b2db678e7ec43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec212d2efc6953ef797b2db678e7ec43">&#9670;&nbsp;</a></span>getMap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const map_t&amp; getMap </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>? but &lt;T&gt; ?</p>

</div>
</div>
<a id="a8dfbff0fda4c400c3edcd0ae920f573d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8dfbff0fda4c400c3edcd0ae920f573d">&#9670;&nbsp;</a></span>importCastableMap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void importCastableMap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrain_1_1SmartMap.html">drain::SmartMap</a>&lt; T2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign values from a map, possibly extending the map. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>- source of keys and values </td></tr>
    <tr><td class="paramname">updateOnly</td><td>- bypass unexisting keys silently, otherwise throw exception. </td></tr>
    <tr><td class="paramname">criticality</td><td>- define sensibility if new keys cannot be added (LOG_NOTE, LOG_ERROR)</td></tr>
  </table>
  </dd>
</dl>
<p>If a key is not known, and the map is of fixed type like <a class="el" href="classdrain_1_1ReferenceMap.html">ReferenceMap</a>, throws exception. </p>

</div>
</div>
<a id="a5eb0e92e99282aa01b5fd0f68b9881d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5eb0e92e99282aa01b5fd0f68b9881d3">&#9670;&nbsp;</a></span>importEntries() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void importEntries </td>
          <td>(</td>
          <td class="paramtype">const std::list&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>entries</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>assignmentSymbol</em> = <code>'='</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entries</td><td>- a sequence containing key=value pairs separated by separator TODO: sequence </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1f8a191f70ea2b677bc6d242d497e4d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f8a191f70ea2b677bc6d242d497e4d7">&#9670;&nbsp;</a></span>importEntries() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void importEntries </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>entries</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>assignmentSymbol</em> = <code>'='</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>separatorSymbol</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assigns a value to given key; if the entry does not exist, tries to create it with directly with operator[]. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">updateOnly</td><td>- if true, only existing elements are updated, otherwise skipped; if false, tries to add elements. </td></tr>
    <tr><td class="paramname">entries</td><td>- string containing key=value pairs separated by separator </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af96c05d0eecedaf1550432f0b74eb304"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af96c05d0eecedaf1550432f0b74eb304">&#9670;&nbsp;</a></span>importMap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void importMap </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; std::string, S &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign values from a map, overriding existing entries. </p>
<dl class="section user"><dt>m - source of keys and values</dt><dd></dd></dl>
<p>If a key is not known, and the map is of fixed type like <a class="el" href="classdrain_1_1ReferenceMap.html">ReferenceMap</a>, throws exception. </p>

</div>
</div>
<a id="a1899a31da0f3cf23bbd08b6c2ed88052"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1899a31da0f3cf23bbd08b6c2ed88052">&#9670;&nbsp;</a></span>operator[]()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual T&amp; operator[] </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an element. Creates one, conditionally. </p>
<ul>
<li>OPEN: creates a new elment</li>
<li>CLOSED: returns a dummy element.</li>
<li>STRICTLY_CLOSED: throws exception </li>
</ul>

</div>
</div>
<a id="ab3c45b7f1a61f1fbdc052cb4c6fb0c6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3c45b7f1a61f1fbdc052cb4c6fb0c6d">&#9670;&nbsp;</a></span>updateFromMap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void updateFromMap </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; std::string, T2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign values from a map. Updates existing entries only. </p>
<dl class="section user"><dt>m - source of keys and values</dt><dd>Convenience </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a3e9d8363daba3503121bd79ad72093b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e9d8363daba3503121bd79ad72093b0">&#9670;&nbsp;</a></span>keyList</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::list&lt;std::string&gt; keyList</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assigns values from std::string of type "value,value2,...valueN". </p>
<p>Allows setting values in python style function calls:</p><ol type="1">
<li>in the definition order of entries: "value,value2,...valueN" become assined as key=value, key2=value2, ... and so on.</li>
<li>specified mode, allowing specific assignments "key=value,key2=value2,key3=value3"</li>
</ol>
<p>Mixed types like <code>"value,key4=value2,value3"</code> accepted but not encouraged. In the mixed mode, the unspecified keys become assigned in \i their order of appearance. Hence, in the above example <code>value3</code> will be assigned to <code>key2</code> , not <code>key3</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">criticality</td><td>- if true, skip non-existing entries silently Defines the 1) valid keys and 2) their order. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>bak/<a class="el" href="SmartMap2_8h_source.html">SmartMap2.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.17-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.9.1
</small></address>
</body>
</html>
